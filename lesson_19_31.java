public class lesson_19_31 {
    //Фильтрация данных
    //Еще 6 методов создают новые потоки данных, позволяющие объединять потоки в цепочки разной сложности.

    //Метод Stream<T> filter(Predicate<T>)

    //Этот метод возвращает новый поток данных, который фильтрует данные из потока-источника согласно переданному правилу.
    //Метод нужно вызывать у объекта типа Stream<T>.
    //Для задания правила фильтрации можно использовать лямбда-функцию,
    //которая затем будет преобразована компилятором в объект типа Predicate<T>.
    //Примеры:
    //Цепочки потоков	                                                Пояснение
    //Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);
    //Stream<Integer> stream2 = stream.filter(x -> (x < 3));            Оставляем только числа меньше трех

    //Stream<Integer> stream = Stream.of(1, -2, 3, -4, 5);
    //Stream<Integer> stream2 = stream.filter(x -> (x > 0));            Оставляем только числа больше нуля


    //Метод Stream<T> sorted(Comparator<T>)

    //Этот метод возвращает новый поток данных, который сортирует данные из потока-источника.
    //В качестве параметра можно передать компаратор, который будет задавать правила сравнения двух элементов потока данных.


    //Метод Stream<T> distinct()

    //Этот метод возвращает новый поток данных, который содержит только уникальные данные из потока данных источника.
    //Все дублирующиеся данные отбрасываются.
    //Пример:
    //Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 2, 2, 2, 3, 4);
    //Stream<Integer> stream2 = stream.distinct();                          // 1, 2, 3, 4, 5


    //Метод Stream<T> peek(Consumer<T>)

    //Этот метод возвращает новый поток данных, хотя данные в нем те же, что и в потоке источнике.
    //Но когда запрашивается очередной элемент из потока, для него вызывается функция, которую вы передали в метод peek().
    //Если в метод peek() передать функцию System.out::println, тогда все объекты будут выводиться на экран в момент,
    //когда они будут проходить через поток.


    //Метод Stream<T> limit(int n)

    //Этот метод возвращает новый поток данных, который содержит только первые n данных из потока данных источника.
    //Все остальные данные отбрасываются.
    //Пример:
    //Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 2, 2, 2, 3, 4);
    //Stream<Integer> stream2 = stream.limit(3);                            // 1, 2, 3


    //Метод Stream<T> skip(int n)

    //Этот метод возвращает новый поток данных, который содержит все те же данные, что и поток-источник,
    //но пропускает (игнорирует) первые n данных.
    //Пример:
    //Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 2, 2, 2, 3, 4);
    //Stream<Integer> stream2 = stream.skip(3);                             // 4, 5, 2, 2, 2, 3, 4
}
